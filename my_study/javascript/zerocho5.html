<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <title>렛츠기릿 자바스크립트</title>
</head>
<body>
    <ul>
        <li>
            <p class="nomal">객체 속성 제거: delete 변수.속성;</p>
        </li>
    </ul>

    <article>
        <h2>객체 - 함수</h2>
        <section>
            <h3>배열 기본</h3>
            <p class="nomal">프로그래밍에서 함수는 일정한 동작을 수행하는 코드를 의미한다. <br>함수를 미리 만들어두고 원할 때 실행해 정해진 동작을 수행하게 할 수 있다.</p>
            <p class="nomal">함수를 만들 때는 보통 function 예약어를 사용하거나 => 화살표 기호를 사용한다.<br>화살표 기호를 사용한 함수를 화살표 함수(arrow funtion)이라고 한다.</p>
            <p class="nomal"><b>function() {}</b><br>또는 <b>() => {}</b></p>
            <h3>함수에 이름 붙이는 방법</h3>
            <p class="nomal">1. <b>function a() {}</b> *이 방식은 함수선언문이라고 칭한다.</p>
            <p class="nomal">2. <b>const b = function() {}</b> *이 방식은 함수표현식이라고 칭한다.</p>
            <p class="nomal">3. <b>const c = () => {};</b> *이 방식은 화살표함수라고 칭한다.</p>
            <h3>함수 만들기</h3>
            <p class="nomal">function a() {<br>console.log('Hello');<br>console.log('Function');<br>}<br><b>a();</b> *호출</p>
            <h3>return 이해하기</h3>
            <p class="nomal">함수를 호출하면 항상 결괏값이 나오는데, 기본값으로 undefined가 나온다.<br>이 값을 반환값(return value)라고 한다.<br>console.log의 함수 반환값은 undefined이다.</p>
            <p class="nomal">function b() {<br>return '반환값';<br>}<br>*함수는 return value가 undefined가 default라고 생각하면 된다.</p>
            <p class="nomal">함수를 선언할 때는 반환값이 없는데, 함수를 선언하면 반환값이 반환해 준다.</p>
            <p class="nomal console">
                <b>return은 반환만 하는 게 아니라 함수를 종료시킨다.</b><br>
                function c() {<br>return 'hello';<br>console.log('hi')<br>} 이걸 실행하면 console은 실행되지 않고 반환값을 반환하고 종료된다.
            </p>
            <p class="nomal">return에서 undefined는 생략 가능하다.</p>
            <p class="nomal console"><b>조건부로 reture도 가능하다.</b><br>function d() {<br>if(true 또는 false){<br>return;<br>}<br>console.log('위 if가 false일 때만 실행!')<br>}</p>
            <p class="nomal">함수의 마지막에는 항상 return undefined가 숨어있다고 생각하라.</p>
            <p class="nomal">return값은 모든 자료형이 가능하다. 심지어 함수를 반환값으로 지정해 줄 수도 있다.</p>
            <h3>return값을 변수로 만들기</h3>
            <p class="nomal">function a() {<br>return 10;<br>}<br>const b = a();<br>console.log(b);</p>
            <p class="nomal">return값도 여러 개가 가능하다. 이럴 땐 배열을 사용하면 된다. *배열 아니면 안 됨. 리턴값은 하나여야 함.<br>function a(){<br>reture [1, 5];<br>}</p>
            <script>
                function c() {
                    return '반환값';
                    console.log('함수는 이미 종료됐어요.');
                }

                c(); //호출 (콘솔에서 직접 실행해야 함)

                //조건부 return
                function d() {
                    if(false){
                        return;
                    }

                    console.log('조건이 false여서 실행 가능합니다.');
                }

                d();

                // return값을 변수로
                function a() {
                    return 10;
                }

                const b = a();
                console.log(b);
            </script>
        </section>

        <section>
            <h3>매개변수와 인수</h3>
            <p class="nomal">매개변수(parameter) / 인수(argument)</p>
            <p class="nomal"><b>function a(parameter) {<br>console.log(parameter);}<br>a('argument')</b></p>
            <p class="nomal">함수를 선언할 때는 매개변수(parameter), 함수를 호출할 때는 인수(argument);</p>
            <p class="nomal">호출할 때 매개변수(parameter)가 인수(argument)자리로 들어간다.</p>
            <p class="nomal">매개변수도 [변수]이기 때문에 함수가 실행되면 <b>parameter = 'argument'</b> 이런 식의 변수가 생성된다고 생각하면 된다.</p>
            <h4>여러 개의 매개변수와 인자</h4>
            <p class="nomal">함수가 하나의 매개변수와 하나의 인수만을 가지는 것이 아니다.<br>각각 여러 개를 가질 수 있고, <b>매개변수와 인수의 개수가 일치하지 않아도 된다.</b></p>
            <p class="nomal">
                function a(w, x, y, z) {<br>console.log(w, x, y, z);<br>console.log(arguments);<br>}<br>a('hello', 'Parameter', 'Argument');<br>
                <b>* w = 'hello' / x = 'Parameter' / y = 'Argument' / z = undefined(기본값);</b>
            </p>
            <p class="nomal">짝이 없는 argument의 기본값은 undefined이고, 짝이 없는 parameter는 무시된다.</p>
            <p class="nomal">function 안에서 [arguments]를 콘솔출력하면 넣었던 인수들을 배열로 출력해 준다.</p>
            <script>
                function aa(w, x, y, z) {
                    console.log(w, x, y, z);
                    console.log(arguments);
                }

                aa('w이다', 'x이다.', 'y이다.');

                //더하기 함수
                function plus(x, y){
                    return x + y;
                }

                console.log(plus(3, 5));
                console.log(plus(5)); //5 + undefined는 NaN이다.

                //화살표 함수
                const aaa = (x, y, z) => {
                    return x * y * z;
                }

                console.log(aaa(2, 3, 4));

                //함수 밖에 있는 값 가져와서 만들기
                const numberr = 100;

                function minus2(x, y) {
                    return (x - y) * numberr;
                }

                console.log(minus2(5, 3));
            </script>
        </section>

        <section>
            <h3>객체 리터럴 기본</h3>
            <p class="nomal"><b>배열도 객체고, 함수도 객체이다.</b></p>
            <p class="nomal">객체 리터럴: 배열이나 함수가 아닌 애들 중에서 특정 모양을 가지면 객체리터럴이라고 부른다.</p>
            <p class="nomal">
                const name = '조현영'<br>const year = '1994'<br>const month = 8;<br>const date = 12;<br>const gender = 'M';<br>
                언뜻 봤을 때는 문제가 없어 보이지만, namd, month 등 다른 사람을 표현할 때 이 변수들을 재사용할 수 없다.<br>이럴 때 객체를 사용하면 여러 개의 변수를 하나로 묶을 수 있다.
            </p>
            <p class="nomal"><b>위 내용을 객체 리터럴로 표현한다면,</b><br>const zerocho = {<br>name: '조현영',<br>year: 1994,<br>month: 8,<br>date: 12,<br>gender: 'M',<br>};</p>
            <p class="nomal">위 내용에서 배열이 아닌 객체를 쓰는 이유와 배열과 객체의 차이점은?<br>배열은 단순히 여러 값들을 하나로 묶어놓은 것이고, 객체는 하나로 묶어놓으면서 각 값의 이름까지 붙여놓은 것이다.</p>
            <p class="nomal">name, year 등의 정보들을 <b>속성(property)</b>라고 한다.<br>속성은 <b>속성 이름</b>과 <b>속성 값</b>으로 구분된다.<br>name(속성 이름) : '조현영'(속성값);</p>
            <p class="nomal">{}를 사용해 객체를 표현하는 것을 객체 리터럴이라고 한다.<br>객체 리터럴 방식으로 객체를 표현하는 것 외에도 다양한 방법으로 객체를 만들 수 있다.</p>
            <p class="nomal"><b>const 객체 = {<br>속성1이름: 속성1값,<br>속성2이름: 속성2값,<br>속성3이름: 속성3값,<br>}</b></p>
            <p class="nomal">속성 이름에 특수문자, 띄어쓰기가 들어가거나 숫자로 시작된다면 따옴표를 붙여줘야 한다.<br>ex)'2ca', 'c a', 'c-a'</p>
            <h4>객체 리터럴을 불러오는 법 [ ]</h4>
            <p class="nomal">const obj = {<br>bc: 'hello1',<br>'2ca': 'hello2',<br>'c a': 'hello3',<br>'c-a': 'hello4',<br>};</p>
            <p class="nomal">1. obj.bc;<br>2. obj['bc'] <i>이 경우 꼭 따옴표를 붙여줘야 한다.</i></p>
            <p class="nomal">없는 속성에 접근하면 undefined가 나온다.</p>
            <h4>객체 속성 수정하기(추가하기)</h4>
            <p class="nomal">zerocho.gender = 'F'; <b>수정을 원하는 속성에 값을 넣어주면 된다.(배열과 비슷함)</b><br>console.log(zerocho.gender);</p>
            <p class="nomal"><b>속성을 추가하는 방법과 동일하다.</b></p>
            <h4>객체 속성 제거하기</h4>
            <p class="nomal"><b>delete</b> zerocho.gender; <b>앞에 delete를 붙여주면 된다.</b><br>console.log(zerocho.gender);</p>
            <p class="nomal">제거된 속성 값은 undefined가 된다.</p>
            <h4>배열과 함수가 객체인 이유</h4>
            <p class="nomal">객체의 성질을 모두 다 사용할 수 있기 때문이다.<br>배열과 함수에도 속성들을 추가할 수 있고, 수정 및 제거할 수 있다.<br>객체는 함수와 배열을 포함하는 개념이라서 {}를 사용해 만든 객체를 리터럴이라고 따로 부르는 것이다.</p>
            <p class="nomal">객체의 하위에 배열, 함수, 객체 리터럴이 존재한다.</p>
            <p class="nomal">function hello() {}<br>hello.a = 'really?';<br>const array = [];<br>array.b = 'wow';<br>console.log(hello.a);<br>console.log(array.b);</p>
            <h4>메서드 이해하기</h4>
            <p class="nomal">속성 값으로 자바스크립트의 모든 값을 넣을 수 있다.<br>문자열도 되고, 숫자, 불 값, null, undefined도 된다.<br>그리고 함수, 배열, 다른 객체까지도 넣을 수 있다.<br><b>객체의 속성 값으로 함수를 넣었을 때 이 속성을 특별히 메서드(method)라고 한다.</b></p>
            <p class="nomal">const debug = {<br>log: function(value) {<br>console.log(value);<br>},<br>};<br>debug.log('hello, method');</p>
            <p class="nomal">debug라는 객체 안에 log라는 속성에 속성 값을 함수로 넣은 것이다. (debug 객체 안에 log 메서드)</p>
            <p class="nomal">console.log도 사실 console이라는 객체 안에 log라는 메서드가 있어서 우리가 사용하는 것이다.</p>
            <script>
                const name = '조현영';
                const year = '1994';
                const month = 8;
                const date = 12;
                const gender = 'M';

                // 위 내용을 객체 리터럴로 표현할 경우
                const zerocho = {
                    name: '조현영', //name은 속성 이름, '조현영'은 속성 값이다.
                    year: '1994',
                    month: 8,
                    date: 12,
                    gender: 'M',
                }
                
                const obj = {
                    bc: 'hello1',
                    '2ca': 'hello2',
                    'c a': 'hello3',
                    'c-a': 'hello4',
                }

                //객체 리터럴을 불러오는 법 []
                console.log('객체 리터럴의 속성값을 불러오는 방법1: ' + obj.bc);
                console.log('객체 리터럴의 속성값을 불러오는 방법2: ' + obj['2ca']);

                //객체 속성 수정하기(추가하기)
                obj.bc = '수정했어요';
                obj['추가'] = '추가했어요';
                console.log(obj)

                //객체 속성 제거하기
                delete obj.bc;
                delete obj['추가'];
                console.log(obj)

                //메서드 이해하기
                const debug = {
                    log: function(aaa){
                        console.log(aaa);
                    }, //log라는 속성의 값은 함수이다.
                };

                debug.log('이것은 aaa 안에 들어갑니다.')
            </script>
        </section>

        <section>
            <h3>객체의 비교(원시값과의 차이점)</h3>
            <h4>객체 간의 비교</h4>
            <p class="nomal">객체를 다룰 때 가장 많이 하는 실수를 하는 상황이 있다.<br>바로 <b>객체 간에 비교 연산을 할 때</b>이다.</p>
            <p class="nomal">객체끼리는 서로 비교하면 불 값이 false가 나온다.<br>{} === {} <i>false</i></p>
            <p class="nomal">객체가 아닌 숫자, 문자열, 불 값, null, undefined는 모두 true를 반환한다.</p>
            <p class="nomal">객체는 모양이 같아도 생성할 때마다 새로운 객체가 생성된다.<br>따라서, 같은 객체인지 비교하고 싶다면 기존 객체를 변수에 저장해둬야 한다.</p>
            <p class="nomal">const a = {name: 'zerocho',};<br>const array = [1, 2, a];<br>console.log(a === array[2]);</p>
            <script>
                console.log({} === {});
                console.log([] === []);
                console.log('str' === 'str');
                console.log(false === false);
                console.log(null === null);
                console.log(undefined === undefined);

                const obj2 = {name: 'zerocho',};
                const objArray = [1, 2, obj2];
                console.log(obj2 === objArray[2]);

                // 조에 접근하기
                const zero = {
                    name: {
                        first: '현영',
                        last: '조',
                    },
                    gender: 'm',
                };

                console.log(zero.name.last);
                console.log(zero['name']['last']);
                // 제로초의 속성은 name과 gender이고, name 안에는 다시 객체가 있는 거다.
            </script>
        </section>
    </article>
</body>
</html>